# 2D Rendering in WebGL
The foundation of 2D rendering in WebGL starts with understanding the coordinate system. While your canvas uses pixel coordinates where (0,0) is at the top-left, WebGL uses a normalized coordinate system where (0,0) is at the center and coordinates range from -1 to 1. This is our first key concept - coordinate transformation. When we specify positions like gl_Position = vec4(x, y, 0, 1), we're working in this normalized space.  
The rendering pipeline begins with vertices. Even for 2D shapes, we need to define them using triangles since WebGL fundamentally only draws triangles. A simple rectangle, for instance, consists of two triangles. We define these vertices using arrays: const vertices = new Float32Array([-0.5, -0.5, 0.5, -0.5, -0.5, 0.5]). This forms our first triangle.
Shaders form the next crucial concept. For 2D rendering, we typically use simpler shaders than their 3D counterparts. A vertex shader might only transform coordinates, while a fragment shader might just output a solid color. The vertex shader handles the position calculations, taking our vertices and preparing them for rendering.     

**Buffer objects** serve as the communication channel between our JavaScript code and the GPU. When we call gl.createBuffer() and gl.bufferData(), we're sending our vertex data to the GPU's memory. This is essential because the GPU needs fast access to this data during rendering.
To add color and texture to our 2D shapes, we work with fragment shaders. The fragment shader determines the color of each pixel in our shape. For a solid color, it might be as simple as gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0) for red. For textures, we use texture coordinates (UV coordinates) to sample from an image.
The concept of texture mapping is particularly important for 2D graphics. We specify how image textures map onto our shapes using texture coordinates. These coordinates are similar to vertex positions but range from 0 to 1 and tell WebGL which part of the texture to apply to each part of our shape.  

Transformation matrices represent another key concept. Even in 2D, we use matrices for translation (moving), rotation, and scaling. A 3x3 matrix can handle all 2D transformations. We typically define these in JavaScript and pass them to our shaders as uniforms: gl.uniformMatrix3fv(matrixLocation, false, transformationMatrix).
Blending becomes important when dealing with transparency or overlapping shapes. We enable it using gl.enable(gl.BLEND) and configure how colors combine using gl.blendFunc(). This is crucial for effects like alpha transparency in sprites or UI elements.